Fortify SAST Integration with Azure DevOps Pipelines ‚Äî Documentation

‚∏ª

1. ‚úÖ Overview

This documentation explains how Fortify SAST scanning is integrated into Azure DevOps pipelines with:
	‚Ä¢	Automated scan triggering
	‚Ä¢	Controlled queueing via lock files
	‚Ä¢	Status monitoring and FPR handling
	‚Ä¢	Automatic cleanup on failure or cancellation
	‚Ä¢	Safe handling of concurrency with minimal manual effort
3. üß† Script Explanation ‚Äî Important Sections

üî∏ 3.1 scan.bat

Purpose:

This script performs the full scan cycle ‚Äî from queuing to scanning to pushing results.

Key Components:

Block
Description
QUEUE_FILE
Each scan creates a uniquely timestamped .queue file. Used to manage scan order.
LOCKFILE
Contains two values: the queue filename and the scan token. Ensures serialized execution.
WAIT_FOR_TURN
Waits for the scan to become first in queue before proceeding. Uses PowerShell-formatted timestamps for ordering.
SCANCENTRAL start
Starts the scan and captures the scan token using string matching.
RETRIEVE STATUS
Polls status using the token until COMPLETED or FAILED.
DOWNLOAD FPR
Downloads the .fpr file once scan completes.
FORTIFYCLIENT uploadFPR
Uploads the result to SSC. Checks for ‚ÄúBackground submission succeeded.‚Äù
CLEANUP
Deletes .fpr, lock, and queue file safely after checking existence.

üî∏ 3.2 cleanup.bat

Purpose:

To clean leftover files and cancel scans when pipeline fails or is cancelled.

Key Components:

Block
Description
READ LOCKFILE
Extracts token and queue filename from lock file.
SCAN STATUS CHECK
If scan is RUNNING or QUEUED, issues scancentral cancel command.
VERIFY CANCEL
Ensures cancellation is successful by checking console output for "Successfully canceled job."
DELETE FILES
Deletes queue and lock files only if safe paths and valid data.

4. üìÇ File & Directory Structure

$(Build.SourcesDirectory)\
‚îú‚îÄ‚îÄ scan.bat
‚îú‚îÄ‚îÄ cleanup.bat
‚îú‚îÄ‚îÄ $(Build.BuildId)\
‚îÇ   ‚îú‚îÄ‚îÄ scan.lock
‚îÇ   ‚îî‚îÄ‚îÄ queue\
‚îÇ       ‚îî‚îÄ‚îÄ 20240627121000.queue

Each scan‚Äôs lock and queue are created in a unique directory using $(Build.BuildId) to avoid interference between parallel builds.
5. üîÑ Pipeline YAML (Simplified)
variables:
  WORKDIR: '$(Build.SourcesDirectory)\$(Build.BuildId)'
  LOCKFILE: '$(WORKDIR)\scan.lock'
  QUEUE_DIR: '$(WORKDIR)\queue'

stages:
- stage: Start_Scan
  jobs:
  - job: RunScan
    steps:
    - script: call scan.bat "ProjectX" "1.0"
      env:
        SSC_TOKEN: $(FORTIFY_CI_TOKEN)
        LOCKFILE: $(LOCKFILE)
        QUEUE_DIR: $(QUEUE_DIR)

- stage: Cleanup_Scan
  condition: failed() OR canceled()
  dependsOn: Start_Scan
  jobs:
  - job: Cleanup
    steps:
    - script: call cleanup.bat
      env:
        LOCKFILE: $(LOCKFILE)
        QUEUE_DIR: $(QUEUE_DIR)


7. üîê Queue Mechanism (for parallel job prevention)
	‚Ä¢	When script starts, it generates a queue file using timestamp: YYYYMMDDHHMMSS.queue
	‚Ä¢	Only the job with the lowest timestamp is allowed to proceed
	‚Ä¢	Others wait and retry every 30 seconds until it‚Äôs their turn
	‚Ä¢	Prevents Fortify resource overload due to multiple concurrent scans

6. üßπ cleanup.bat Script Highlights
	‚Ä¢	Reads QUEUE and TOKEN from lock file
	‚Ä¢	Retrieves scan status using token
	‚Ä¢	If scan is RUNNING or QUEUED, attempts to cancel:

5. üìú scan.bat Script Highlights
	‚Ä¢	Creates a lock file containing:
	‚Ä¢	QUEUE=20240627093000.queue
	‚Ä¢	TOKEN=abc-xyz-token
	‚Ä¢	Starts scan using:
scancentral -url <controller-url> start -bt none
Polls for scan status:
	‚Ä¢	Waits until status is COMPLETED
	‚Ä¢	Downloads .fpr file
	‚Ä¢	Uploads .fpr to SSC using fortifyclient
	‚Ä¢	On success, deletes .fpr, lock, and queue file




Fortify SAST scans are CPU- and memory-intensive and often consume licensing capacity. Running multiple scans concurrently on the same server (especially with multiple agents) can lead to:
	‚Ä¢	Resource exhaustion
	‚Ä¢	Scan failures
	‚Ä¢	Licensing errors

To avoid conflicts, we implemented a synchronized, serialized scan execution mechanism using:
	‚Ä¢	A lock file to represent an active scan
	‚Ä¢	A queue file (FIFO) for orderly scan requests
	‚Ä¢	Logic to allow only one scan to execute at a time

‚∏ª

üîÑ Workflow Overview
	1.	When a scan starts, it creates a timestamp-based .queue file in a defined directory.
	2.	Each scan checks:
	‚Ä¢	If it is the oldest .queue file (i.e., first in line)
	‚Ä¢	If so, it creates a lock file and begins scanning.
	‚Ä¢	If not, it waits until its turn by polling periodically.
	3.	Once the scan finishes, the script:
	‚Ä¢	Deletes the .fpr result file
	‚Ä¢	Uploads to SSC
	‚Ä¢	Deletes the .lock and .queue files

‚∏ª

üîß Implementation Breakdown

üìÅ Queue File
	‚Ä¢	Location: $(Build.SourcesDirectory)\$(Build.BuildId)\queue\
	‚Ä¢	Format: YYYYMMDDHHMMSS.queue
	‚Ä¢	Purpose: Establishes order based on creation time.

üîê Lock File
	‚Ä¢	Location: $(Build.SourcesDirectory)\$(Build.BuildId)\scan.lock
	‚Ä¢	Contents:

QUEUE=<queue_file_name>
TOKEN=<scan_token>

Purpose:
	‚Ä¢	Indicates a scan is in progress
	‚Ä¢	Holds metadata to cancel the scan if needed (from another pipeline stage)

‚∏ª

üßÆ FIFO Logic

In the batch script:

for /f %%F in ('dir /b /o:n "%QUEUE_DIR%\*.queue"') do (
   set FIRST=%%F
   goto CHECK_FIRST
)

This fetches the oldest file in the queue directory.
	‚Ä¢	The current scan compares its file name (extracted from its queue_file) with the oldest.
	‚Ä¢	If matched, it proceeds with scanning.
	‚Ä¢	If not, it waits (e.g., 10 seconds) and checks again.

How It Works with Multiple Agents

Scenario: Multiple Azure DevOps Agents on One Server

Each agent runs in isolation but shares the same disk/queue directory, which means:
	1.	Each pipeline run (from any agent) creates its own:
	‚Ä¢	Unique BuildId-scoped directory (e.g., C:\Agent\_work\10\...)
	‚Ä¢	.queue file within the common queue folder
	2.	Queue & Lock files are shared:
	‚Ä¢	All agents check the same queue directory before starting scans
	‚Ä¢	This ensures only one agent at a time executes the scan


What if an Agent/Pipeline Fails or is Cancelled?
	‚Ä¢	scan.lock contains the token and queue filename
	‚Ä¢	If the build is canceled, a cleanup script is triggered
	‚Ä¢	The cleanup script reads the lock file and:
	‚Ä¢	Cancels the scan (if RUNNING or QUEUED)
	‚Ä¢	Deletes the .lock and .queue file



